.TH "vendor/jetbrains/phpstorm-stubs/mbstring/mbstring.php" 3 "Sat Sep 26 2020" "Safaricom SDP" \" -*- nroff -*-
.ad l
.nh
.SH NAME
vendor/jetbrains/phpstorm-stubs/mbstring/mbstring.php
.SH SYNOPSIS
.br
.PP
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBmb_convert_case\fP ($str, $mode, $encoding=\fBnull\fP)"
.br
.ti -1c
.RI "\fBmb_strtoupper\fP ($str, $encoding=\fBnull\fP)"
.br
.ti -1c
.RI "\fBmb_strtolower\fP ($str, $encoding=\fBnull\fP)"
.br
.ti -1c
.RI "\fBmb_language\fP ($language=\fBnull\fP)"
.br
.ti -1c
.RI "\fBmb_internal_encoding\fP ($encoding=\fBnull\fP)"
.br
.ti -1c
.RI "\fBmb_http_input\fP ($type=\fBnull\fP)"
.br
.ti -1c
.RI "\fBmb_http_output\fP ($encoding=\fBnull\fP)"
.br
.ti -1c
.RI "\fBmb_detect_order\fP ($encoding_list=\fBnull\fP)"
.br
.ti -1c
.RI "\fBmb_substitute_character\fP ($substrchar=\fBnull\fP)"
.br
.ti -1c
.RI "\fBmb_parse_str\fP ($encoded_string, array &$result=\fBnull\fP)"
.br
.ti -1c
.RI "\fBmb_output_handler\fP ($contents, $status)"
.br
.ti -1c
.RI "\fBmb_preferred_mime_name\fP ($encoding)"
.br
.ti -1c
.RI "\fBmb_strlen\fP ($str, $encoding=\fBnull\fP)"
.br
.ti -1c
.RI "\fBmb_strpos\fP ($haystack, $needle, $offset=0, $encoding=\fBnull\fP)"
.br
.ti -1c
.RI "\fBmb_strrpos\fP ($haystack, $needle, $offset=0, $encoding=\fBnull\fP)"
.br
.ti -1c
.RI "\fBmb_stripos\fP ($haystack, $needle, $offset=0, $encoding=\fBnull\fP)"
.br
.ti -1c
.RI "\fBmb_strripos\fP ($haystack, $needle, $offset=0, $encoding=\fBnull\fP)"
.br
.ti -1c
.RI "\fBmb_strstr\fP ($haystack, $needle, $before_needle=\fBfalse\fP, $encoding=\fBnull\fP)"
.br
.ti -1c
.RI "\fBmb_strrchr\fP ($haystack, $needle, $before_needle=\fBfalse\fP, $encoding=\fBnull\fP)"
.br
.ti -1c
.RI "\fBmb_stristr\fP ($haystack, $needle, $before_needle=\fBfalse\fP, $encoding=\fBnull\fP)"
.br
.ti -1c
.RI "\fBmb_strrichr\fP ($haystack, $needle, $before_needle=\fBfalse\fP, $encoding=\fBnull\fP)"
.br
.ti -1c
.RI "\fBmb_substr_count\fP ($haystack, $needle, $encoding=\fBnull\fP)"
.br
.ti -1c
.RI "\fBmb_substr\fP ($str, $start, $length=\fBnull\fP, $encoding=\fBnull\fP)"
.br
.ti -1c
.RI "\fBmb_strcut\fP ($str, $start, $length=\fBnull\fP, $encoding=\fBnull\fP)"
.br
.ti -1c
.RI "\fBmb_strwidth\fP ($str, $encoding=\fBnull\fP)"
.br
.ti -1c
.RI "\fBmb_strimwidth\fP ($str, $start, $width, $trimmarker=\fBnull\fP, $encoding=\fBnull\fP)"
.br
.ti -1c
.RI "\fBmb_convert_encoding\fP ($str, $to_encoding, $from_encoding=\fBnull\fP)"
.br
.ti -1c
.RI "\fBmb_detect_encoding\fP ($str, $encoding_list=\fBnull\fP, $strict=\fBfalse\fP)"
.br
.ti -1c
.RI "\fBmb_list_encodings\fP ()"
.br
.ti -1c
.RI "\fBmb_encoding_aliases\fP ($encoding)"
.br
.ti -1c
.RI "\fBmb_convert_kana\fP ($str, $option=\fBnull\fP, $encoding=\fBnull\fP)"
.br
.ti -1c
.RI "\fBmb_encode_mimeheader\fP ($str, $charset=\fBnull\fP, $transfer_encoding=\fBnull\fP, $linefeed=\fBnull\fP, $indent=\fBnull\fP)"
.br
.ti -1c
.RI "\fBmb_decode_mimeheader\fP ($str)"
.br
.ti -1c
.RI "\fBmb_convert_variables\fP ($to_encoding, $from_encoding, &\&.\&.\&. $vars)"
.br
.ti -1c
.RI "\fBmb_encode_numericentity\fP ($str, array $convmap, $encoding=\fBnull\fP, $is_hex=\fBfalse\fP)"
.br
.ti -1c
.RI "\fBmb_decode_numericentity\fP ($str, array $convmap, $encoding=\fBnull\fP, $is_hex=\fBfalse\fP)"
.br
.ti -1c
.RI "\fBmb_send_mail\fP ($to, $subject, $message, $additional_headers=\fBnull\fP, $additional_parameter=\fBnull\fP)"
.br
.ti -1c
.RI "\fBmb_get_info\fP ($type=\fBnull\fP)"
.br
.ti -1c
.RI "\fBmb_check_encoding\fP ($var=\fBnull\fP, $encoding=\fBnull\fP)"
.br
.ti -1c
.RI "\fBmb_regex_encoding\fP ($encoding=\fBnull\fP)"
.br
.ti -1c
.RI "\fBmb_regex_set_options\fP ($options=\fBnull\fP)"
.br
.ti -1c
.RI "\fBmb_ereg\fP ($pattern, $string, array &$regs=\fBnull\fP)"
.br
.ti -1c
.RI "\fBmb_eregi\fP ($pattern, $string, array &$regs=\fBnull\fP)"
.br
.ti -1c
.RI "\fBmb_ereg_replace\fP ($pattern, $replacement, $string, $option='msr')"
.br
.ti -1c
.RI "\fBmb_ereg_replace_callback\fP ($pattern, callable $\fBcallback\fP, $string, $option='msr')"
.br
.ti -1c
.RI "\fBmb_eregi_replace\fP ($pattern, $replace, $string, $option='msr')"
.br
.ti -1c
.RI "\fBmb_split\fP ($pattern, $string, $limit=\fBnull\fP)"
.br
.ti -1c
.RI "\fBmb_ereg_match\fP ($pattern, $string, $option=\fBnull\fP)"
.br
.ti -1c
.RI "\fBmb_ereg_search\fP ($pattern=\fBnull\fP, $option=\fBnull\fP)"
.br
.ti -1c
.RI "\fBmb_ereg_search_pos\fP ($pattern=\fBnull\fP, $option=\fBnull\fP)"
.br
.ti -1c
.RI "\fBmb_ereg_search_regs\fP ($pattern=\fBnull\fP, $option=\fBnull\fP)"
.br
.ti -1c
.RI "\fBmb_ereg_search_init\fP ($string, $pattern=\fBnull\fP, $option=\fBnull\fP)"
.br
.ti -1c
.RI "\fBmb_ereg_search_getregs\fP ()"
.br
.ti -1c
.RI "\fBmb_ereg_search_getpos\fP ()"
.br
.ti -1c
.RI "\fBmb_ereg_search_setpos\fP ($position)"
.br
.ti -1c
.RI "\fBmbregex_encoding\fP ($encoding)"
.br
.ti -1c
.RI "\fBmbereg\fP ($pattern, $string, &$registers)"
.br
.ti -1c
.RI "\fBmberegi\fP ($pattern, $string, &$registers)"
.br
.ti -1c
.RI "\fBmbereg_replace\fP ($pattern, $replacement, $string, $option)"
.br
.ti -1c
.RI "\fBmberegi_replace\fP ($pattern, $replacement, $string, string $option='msri')"
.br
.ti -1c
.RI "\fBmbsplit\fP ($pattern, $string, $limit)"
.br
.ti -1c
.RI "\fBmbereg_match\fP ($pattern, $string, $option)"
.br
.ti -1c
.RI "\fBmbereg_search\fP ($pattern, $option)"
.br
.ti -1c
.RI "\fBmbereg_search_pos\fP ($pattern, $option)"
.br
.ti -1c
.RI "\fBmbereg_search_regs\fP ($pattern, $option)"
.br
.ti -1c
.RI "\fBmbereg_search_init\fP ($string, $pattern, $option)"
.br
.ti -1c
.RI "\fBmbereg_search_getregs\fP ()"
.br
.ti -1c
.RI "\fBmbereg_search_getpos\fP ()"
.br
.ti -1c
.RI "\fBmb_chr\fP ($cp, $encoding)"
.br
.ti -1c
.RI "\fBmb_ord\fP ($str, $encoding)"
.br
.ti -1c
.RI "\fBmb_scrub\fP ($str, $encoding)"
.br
.ti -1c
.RI "\fBmbereg_search_setpos\fP ($position)"
.br
.ti -1c
.RI "\fBmb_str_split\fP ($str, $split_length, $encoding)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "const \fBMB_OVERLOAD_MAIL\fP 1"
.br
.ti -1c
.RI "const \fBMB_OVERLOAD_STRING\fP 2"
.br
.ti -1c
.RI "const \fBMB_OVERLOAD_REGEX\fP 4"
.br
.ti -1c
.RI "const \fBMB_CASE_UPPER\fP 0"
.br
.ti -1c
.RI "const \fBMB_CASE_LOWER\fP 1"
.br
.ti -1c
.RI "const \fBMB_CASE_TITLE\fP 2"
.br
.ti -1c
.RI "const \fBMB_CASE_FOLD\fP 3"
.br
.ti -1c
.RI "const \fBMB_CASE_UPPER_SIMPLE\fP 4"
.br
.ti -1c
.RI "const \fBMB_CASE_LOWER_SIMPLE\fP 5"
.br
.ti -1c
.RI "const \fBMB_CASE_TITLE_SIMPLE\fP 6"
.br
.ti -1c
.RI "const \fBMB_CASE_FOLD_SIMPLE\fP 7"
.br
.ti -1c
.RI "const \fBMB_ONIGURUMA_VERSION\fP '6\&.9\&.1'"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "mb_check_encoding ( $var = \fC\fBnull\fP\fP,  $encoding = \fC\fBnull\fP\fP)"
Check if the string is valid for the specified encoding \fBstring|array $var [optional] \fP The byte stream to check\&. If it is omitted, this function checks all the input from the beginning of the request\&. 
.PP
\fBParameters\fP
.RS 4
\fI$encoding\fP [optional] 
.RE
.PP
The expected encoding\&. 
.PP
\fBReturns\fP
.RS 4
bool true on success or false on failure\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.4\&.3 
.PP
5\&.1\&.3 
.RE
.PP

.SS "mb_chr ( $cp,  $encoding)"
Get a specific character\&. \fBint $cp  string $encoding  string|false specific character or FALSE on failure\&.  7\&.2 \fP
.SS "mb_convert_case ( $str,  $mode,  $encoding = \fC\fBnull\fP\fP)"
Perform case folding on a string \fBstring $str \fP The string being converted\&. 
.PP
\fBParameters\fP
.RS 4
\fI$mode\fP 
.RE
.PP
The mode of the conversion\&. It can be one of MB_CASE_UPPER, MB_CASE_LOWER, or MB_CASE_TITLE\&. 
.PP
\fBParameters\fP
.RS 4
\fI$encoding\fP [optional] &mbstring\&.encoding\&.parameter; 
.RE
.PP
\fBReturns\fP
.RS 4
string \fBA\fP case folded version of string converted in the way specified by mode\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.3 
.PP
5\&.0 
.RE
.PP

.SS "mb_convert_encoding ( $str,  $to_encoding,  $from_encoding = \fC\fBnull\fP\fP)"
Convert character encoding \fBstring|array $str \fP The string being encoded\&. 
.PP
\fBParameters\fP
.RS 4
\fI$to_encoding\fP 
.RE
.PP
The type of encoding that str is being converted to\&. 
.PP
\fBParameters\fP
.RS 4
\fI$from_encoding\fP [optional] 
.RE
.PP
Is specified by character code names before conversion\&. It is either an array, or a comma separated enumerated list\&. If from_encoding is not specified, the internal encoding will be used\&. 
.PP
'auto' may be used, which expands to 'ASCII,JIS,UTF-8,EUC-JP,SJIS'\&. 
.PP
\fBReturns\fP
.RS 4
string The encoded string\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.6 
.PP
5\&.0 
.RE
.PP

.SS "mb_convert_kana ( $str,  $option = \fC\fBnull\fP\fP,  $encoding = \fC\fBnull\fP\fP)"
Convert 'kana' one from another ('zen-kaku', 'han-kaku' and more) \fBstring $str \fP The string being converted\&. 
.PP
\fBParameters\fP
.RS 4
\fI$option\fP [optional] 
.RE
.PP
The conversion option\&. 
.PP
Specify with a combination of following options\&. Conversion Options 
.PP
Option 
.PP
Meaning  
.PP
r 
.PP
Convert 'zen-kaku' alphabets to 'han-kaku'   
.PP
R 
.PP
Convert 'han-kaku' alphabets to 'zen-kaku'   
.PP
n 
.PP
Convert 'zen-kaku' numbers to 'han-kaku'   
.PP
N 
.PP
Convert 'han-kaku' numbers to 'zen-kaku'   
.PP
a 
.PP
Convert 'zen-kaku' alphabets and numbers to 'han-kaku'   
.PP
\fBA\fP 
.PP
Convert 'han-kaku' alphabets and numbers to 'zen-kaku' (Characters included in 'a', 'A' options are U+0021 - U+007E excluding U+0022, U+0027, U+005C, U+007E)   
.PP
s 
.PP
Convert 'zen-kaku' space to 'han-kaku' (U+3000 -> U+0020)   
.PP
S 
.PP
Convert 'han-kaku' space to 'zen-kaku' (U+0020 -> U+3000)   
.PP
k 
.PP
Convert 'zen-kaku kata-kana' to 'han-kaku kata-kana'   
.PP
K 
.PP
Convert 'han-kaku kata-kana' to 'zen-kaku kata-kana'   
.PP
h 
.PP
Convert 'zen-kaku hira-gana' to 'han-kaku kata-kana'   
.PP
H 
.PP
Convert 'han-kaku kata-kana' to 'zen-kaku hira-gana'   
.PP
c 
.PP
Convert 'zen-kaku kata-kana' to 'zen-kaku hira-gana'   
.PP
C 
.PP
Convert 'zen-kaku hira-gana' to 'zen-kaku kata-kana'   
.PP
V 
.PP
Collapse voiced sound notation and convert them into a character\&. Use with 'K','H'   
.PP
\fBParameters\fP
.RS 4
\fI$encoding\fP [optional] &mbstring\&.encoding\&.parameter; 
.RE
.PP
\fBReturns\fP
.RS 4
string The converted string\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.6 
.PP
5\&.0 
.RE
.PP

.SS "mb_convert_variables ( $to_encoding,  $from_encoding, &\&.\&.\&. $vars)"
Convert character code in variable(s) \fBstring $to_encoding \fP The encoding that the string is being converted to\&. 
.PP
\fBParameters\fP
.RS 4
\fI$from_encoding\fP 
.RE
.PP
from_encoding is specified as an array or comma separated string, it tries to detect encoding from from-coding\&. When from_encoding is omitted, detect_order is used\&. 
.PP
\fBParameters\fP
.RS 4
\fI$vars\fP 
.RE
.PP
vars is the reference to the variable being converted\&. String, Array and Object are accepted\&. mb_convert_variables assumes all parameters have the same encoding\&. 
.PP
\fBReturns\fP
.RS 4
string|false The character encoding before conversion for success, or false for failure\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.6 
.PP
5\&.0 
.RE
.PP

.SS "mb_decode_mimeheader ( $str)"
Decode string in MIME header field \fBstring $str \fP The string being decoded\&. 
.PP
\fBReturns\fP
.RS 4
string The decoded string in internal character encoding\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.6 
.PP
5\&.0 
.RE
.PP

.SS "mb_decode_numericentity ( $str, array $convmap,  $encoding = \fC\fBnull\fP\fP,  $is_hex = \fC\fBfalse\fP\fP)"
Decode HTML numeric string reference to character \fBstring $str \fP The string being decoded\&. 
.PP
\fBParameters\fP
.RS 4
\fI$convmap\fP 
.RE
.PP
convmap is an array that specifies the code area to convert\&. 
.PP
\fBParameters\fP
.RS 4
\fI$encoding\fP &mbstring\&.encoding\&.parameter; 
.br
\fI$is_hex\fP [optional] 
.RE
.PP
this parameter is not used\&. 
.PP
\fBReturns\fP
.RS 4
string|false|null The converted string\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.6 
.PP
5\&.0 
.RE
.PP

.SS "mb_detect_encoding ( $str,  $encoding_list = \fC\fBnull\fP\fP,  $strict = \fC\fBfalse\fP\fP)"
Detect character encoding \fBstring $str \fP The string being detected\&. 
.PP
\fBParameters\fP
.RS 4
\fI$encoding_list\fP [optional] 
.RE
.PP
encoding_list is list of character encoding\&. Encoding order may be specified by array or comma separated list string\&. 
.PP
If encoding_list is omitted, detect_order is used\&. 
.PP
\fBParameters\fP
.RS 4
\fI$strict\fP [optional] 
.RE
.PP
strict specifies whether to use the strict encoding detection or not\&. Default is false\&. 
.PP
\fBReturns\fP
.RS 4
string|false The detected character encoding or false if the encoding cannot be detected from the given string\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.6 
.PP
5\&.0 
.RE
.PP

.SS "mb_detect_order ( $encoding_list = \fC\fBnull\fP\fP)"
Set/Get character encoding detection order \fBmixed $encoding_list [optional] \fP encoding_list is an array or comma separated list of character encoding\&. ('auto' is expanded to 'ASCII, JIS, UTF-8, EUC-JP, SJIS') 
.PP
If encoding_list is omitted, it returns the current character encoding detection order as array\&. 
.PP
This setting affects mb_detect_encoding and mb_send_mail\&. 
.PP
mbstring currently implements the following encoding detection filters\&. If there is an invalid byte sequence for the following encodings, encoding detection will fail\&. 
.PP
UTF-8, UTF-7, ASCII, EUC-JP,SJIS, eucJP-win, SJIS-win, JIS, ISO-2022-JP 
.PP
For ISO-8859-*, mbstring always detects as ISO-8859-*\&. 
.PP
For UTF-16, UTF-32, UCS2 and UCS4, encoding detection will fail always\&. 
.PP
Useless detect order example 
.PP
\fBReturns\fP
.RS 4
bool|string[] When setting the encoding detection order, true is returned on success or FALSE on failure\&. When getting the encoding detection order, an ordered array of the encodings is returned\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.6 
.PP
5\&.0 
.RE
.PP

.SS "mb_encode_mimeheader ( $str,  $charset = \fC\fBnull\fP\fP,  $transfer_encoding = \fC\fBnull\fP\fP,  $linefeed = \fC\fBnull\fP\fP,  $indent = \fC\fBnull\fP\fP)"
Encode string for MIME header \fBstring $str \fP The string being encoded\&. 
.PP
\fBParameters\fP
.RS 4
\fI$charset\fP [optional] 
.RE
.PP
charset specifies the name of the character set in which str is represented in\&. The default value is determined by the current NLS setting (mbstring\&.language)\&. mb_internal_encoding should be set to same encoding\&. 
.PP
\fBParameters\fP
.RS 4
\fI$transfer_encoding\fP [optional] 
.RE
.PP
transfer_encoding specifies the scheme of MIME encoding\&. It should be either 'B' (Base64) or 'Q' (Quoted-Printable)\&. Falls back to 'B' if not given\&. 
.PP
\fBParameters\fP
.RS 4
\fI$linefeed\fP [optional] 
.RE
.PP
linefeed specifies the EOL (end-of-line) marker with which mb_encode_mimeheader performs line-folding (a RFC term, the act of breaking a line longer than a certain length into multiple lines\&. The length is currently hard-coded to 74 characters)\&. Falls back to '\\r\\n' (CRLF) if not given\&. 
.PP
\fBParameters\fP
.RS 4
\fI$indent\fP [optional] 
.RE
.PP
Indentation of the first line (number of characters in the header before str)\&. 
.PP
\fBReturns\fP
.RS 4
string \fBA\fP converted version of the string represented in ASCII\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.6 
.PP
5\&.0 
.RE
.PP

.SS "mb_encode_numericentity ( $str, array $convmap,  $encoding = \fC\fBnull\fP\fP,  $is_hex = \fC\fBfalse\fP\fP)"
Encode character to HTML numeric string reference \fBstring $str \fP The string being encoded\&. 
.PP
\fBParameters\fP
.RS 4
\fI$convmap\fP 
.RE
.PP
convmap is array specifies code area to convert\&. 
.PP
\fBParameters\fP
.RS 4
\fI$encoding\fP &mbstring\&.encoding\&.parameter; 
.br
\fI$is_hex\fP [optional] 
.RE
.PP
\fBReturns\fP
.RS 4
string|false|null The converted string\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.6 
.PP
5\&.0 
.RE
.PP

.SS "mb_encoding_aliases ( $encoding)"
Get aliases of a known encoding type 
.PP
\fBParameters\fP
.RS 4
\fI$encoding\fP The encoding type being checked, for aliases\&. 
.RE
.PP
\fBReturns\fP
.RS 4
string[]|false a numerically indexed array of encoding aliases on success, or FALSE on failure \fB5\&.3 \fP
.RE
.PP

.SS "mb_ereg ( $pattern,  $string, array & $regs = \fC\fBnull\fP\fP)"
Regular expression match with multibyte support \fBstring $pattern \fP The search pattern\&. 
.PP
\fBParameters\fP
.RS 4
\fI$string\fP 
.RE
.PP
The search string\&. 
.PP
\fBParameters\fP
.RS 4
\fI$regs\fP [optional] 
.RE
.PP
Contains a substring of the matched string\&. 
.PP
\fBReturns\fP
.RS 4
int 
.RE
.PP
\fBSince\fP
.RS 4
4\&.2 
.PP
5\&.0 
.RE
.PP

.SS "mb_ereg_match ( $pattern,  $string,  $option = \fC\fBnull\fP\fP)"
Regular expression match for multibyte string \fBstring $pattern \fP The regular expression pattern\&. 
.PP
\fBParameters\fP
.RS 4
\fI$string\fP 
.RE
.PP
The string being evaluated\&. 
.PP
\fBParameters\fP
.RS 4
\fI$option\fP [optional] 
.RE
.PP
.PP
\fBReturns\fP
.RS 4
bool 
.RE
.PP
\fBSince\fP
.RS 4
4\&.2 
.PP
5\&.0 
.RE
.PP

.SS "mb_ereg_replace ( $pattern,  $replacement,  $string,  $option = \fC'msr'\fP)"
Replace regular expression with multibyte support \fBstring $pattern \fP The regular expression pattern\&. 
.PP
Multibyte characters may be used in pattern\&. 
.PP
\fBParameters\fP
.RS 4
\fI$replacement\fP 
.RE
.PP
The replacement text\&. 
.PP
\fBParameters\fP
.RS 4
\fI$string\fP 
.RE
.PP
The string being checked\&. 
.PP
\fBParameters\fP
.RS 4
\fI$option\fP [optional] Matching condition can be set by option parameter\&. If i is specified for this parameter, the case will be ignored\&. If x is specified, white space will be ignored\&. If m is specified, match will be executed in multiline mode and line break will be included in '\&.'\&. If p is specified, match will be executed in POSIX mode, line break will be considered as normal character\&. If e is specified, replacement string will be evaluated as PHP expression\&. 
.RE
.PP
PHP 7\&.1: The \fIe\fP modifier has been deprecated\&.
.PP
\fBReturns\fP
.RS 4
string|false The resultant string on success, or false on error\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.2 
.PP
5\&.0 
.RE
.PP

.SS "mb_ereg_replace_callback ( $pattern, callable $callback,  $string,  $option = \fC'msr'\fP)"
Perform a regular expresssion seach and replace with multibyte support using a callback \fBstring $pattern \fP The regular expression pattern\&. 
.PP
Multibyte characters may be used in \fBpattern\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fI$callback\fP 
.RE
.PP
\fBA\fP callback that will be called and passed an array of matched elements in the \fBsubject\fP string\&. The callback should return the replacement string\&. 
.PP
You'll often need the \fBcallback\fP function for a \fB\fBmb_ereg_replace_callback()\fP\fP in just one place\&. In this case you can use an anonymous function to declare the callback within the call to \fB\fBmb_ereg_replace_callback()\fP\fP\&. By doing it this way you have all information for the call in one place and do not clutter the function namespace with a callback function's name not used anywhere else\&. 
.PP
\fBParameters\fP
.RS 4
\fI$string\fP 
.RE
.PP
The string being checked\&. 
.PP
\fBParameters\fP
.RS 4
\fI$option\fP [optional 
.RE
.PP
Matching condition can be set by \fI\fBoption\fP\fP parameter\&. If \fIi\fP is specified for this parameter, the case will be ignored\&. If \fIx\fP is specified, white space will be ignored\&. If \fIm\fP is specified, match will be executed in multiline mode and line break will be included in '\&.'\&. If \fIp\fP is specified, match will be executed in POSIX mode, line break will be considered as normal character\&. Note that \fIe\fP cannot be used for \fB\fBmb_ereg_replace_callback()\fP\fP\&. 
.PP
\fBReturns\fP
.RS 4
string|false 
.RE
.PP
The resultant string on success, or \fBFALSE\fP on error\&. 
.PP
\fBSince\fP
.RS 4
5\&.4\&.1 
.RE
.PP

.SS "mb_ereg_search ( $pattern = \fC\fBnull\fP\fP,  $option = \fC\fBnull\fP\fP)"
Multibyte regular expression match for predefined multibyte string \fBstring $pattern [optional] \fP The search pattern\&. 
.PP
\fBParameters\fP
.RS 4
\fI$option\fP [optional] 
.RE
.PP
The search option\&. 
.PP
\fBReturns\fP
.RS 4
bool 
.RE
.PP
\fBSince\fP
.RS 4
4\&.2 
.PP
5\&.0 
.RE
.PP

.SS "mb_ereg_search_getpos ()"
Returns start point for next regular expression match \fBint  4\&.2  5\&.0  deprecated 61\&. \fP
.SS "mb_ereg_search_getregs ()"
Retrieve the result from the last multibyte regular expression match \fBstring[]|false An array including the sub-string of matched part by last mb_ereg_search(), mb_ereg_search_pos(), mb_ereg_search_regs()\&. If there are some matches, the first element will have the matched sub-string, the second element will have the first part grouped with brackets, the third element will have the second part grouped with brackets, and so on\&. It returns FALSE on error;  4\&.2  5\&.0 \fP
.SS "mb_ereg_search_init ( $string,  $pattern = \fC\fBnull\fP\fP,  $option = \fC\fBnull\fP\fP)"
Setup string and regular expression for a multibyte regular expression match \fBstring $string \fP The search string\&. 
.PP
\fBParameters\fP
.RS 4
\fI$pattern\fP [optional] 
.RE
.PP
The search pattern\&. 
.PP
\fBParameters\fP
.RS 4
\fI$option\fP [optional] 
.RE
.PP
The search option\&. 
.PP
\fBReturns\fP
.RS 4
bool 
.RE
.PP
\fBSince\fP
.RS 4
4\&.2 
.PP
5\&.0 
.RE
.PP

.SS "mb_ereg_search_pos ( $pattern = \fC\fBnull\fP\fP,  $option = \fC\fBnull\fP\fP)"
Returns position and length of a matched part of the multibyte regular expression for a predefined multibyte string \fBstring $pattern [optional] \fP The search pattern\&. 
.PP
\fBParameters\fP
.RS 4
\fI$option\fP [optional] 
.RE
.PP
The search option\&. 
.PP
\fBReturns\fP
.RS 4
int[]|false An array containing two elements\&. The first element is the offset, in bytes, where the match begins relative to the start of the search string, and the second element is the length in bytes of the match\&. If an error occurs, FALSE is returned\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.2 
.PP
5\&.0 
.RE
.PP

.SS "mb_ereg_search_regs ( $pattern = \fC\fBnull\fP\fP,  $option = \fC\fBnull\fP\fP)"
Returns the matched part of a multibyte regular expression \fBstring $pattern [optional] \fP The search pattern\&. 
.PP
\fBParameters\fP
.RS 4
\fI$option\fP [optional] 
.RE
.PP
The search option\&. 
.PP
\fBReturns\fP
.RS 4
string[]|false \fBmb_ereg_search_regs()\fP executes the multibyte regular expression match, and if there are some matched part, it returns an array including substring of matched part as first element, the first grouped part with brackets as second element, the second grouped part as third element, and so on\&. It returns FALSE on error\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.2 
.PP
5\&.0 
.RE
.PP

.SS "mb_ereg_search_setpos ( $position)"
Set start point of next regular expression match \fBint $position \fP The position to set\&. 
.PP
\fBReturns\fP
.RS 4
bool 
.RE
.PP
\fBSince\fP
.RS 4
4\&.2 
.PP
5\&.0 
.RE
.PP

.SS "mb_eregi ( $pattern,  $string, array & $regs = \fC\fBnull\fP\fP)"
Regular expression match ignoring case with multibyte support \fBstring $pattern \fP The regular expression pattern\&. 
.PP
\fBParameters\fP
.RS 4
\fI$string\fP 
.RE
.PP
The string being searched\&. 
.PP
\fBParameters\fP
.RS 4
\fI$regs\fP [optional] 
.RE
.PP
Contains a substring of the matched string\&. 
.PP
\fBReturns\fP
.RS 4
int 
.RE
.PP
\fBSince\fP
.RS 4
4\&.2 
.PP
5\&.0 
.RE
.PP

.SS "mb_eregi_replace ( $pattern,  $replace,  $string,  $option = \fC'msr'\fP)"
Replace regular expression with multibyte support ignoring case \fBstring $pattern \fP The regular expression pattern\&. Multibyte characters may be used\&. The case will be ignored\&. 
.PP
\fBParameters\fP
.RS 4
\fI$replace\fP 
.RE
.PP
The replacement text\&. 
.PP
\fBParameters\fP
.RS 4
\fI$string\fP 
.RE
.PP
The searched string\&. 
.PP
\fBParameters\fP
.RS 4
\fI$option\fP [optional] option has the same meaning as in mb_ereg_replace\&. 
.RE
.PP
PHP 7\&.1: The \fIe\fP modifier has been deprecated\&.
.PP
\fBReturns\fP
.RS 4
string|false The resultant string or false on error\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.2 
.PP
5\&.0 
.RE
.PP

.SS "mb_get_info ( $type = \fC\fBnull\fP\fP)"
Get internal settings of mbstring \fBstring $type [optional] \fP If type isn't specified or is specified to 'all', an array having the elements 'internal_encoding', 'http_output', 'http_input', 'func_overload', 'mail_charset', 'mail_header_encoding', 'mail_body_encoding' will be returned\&. 
.PP
If type is specified as 'http_output', 'http_input', 'internal_encoding', 'func_overload', the specified setting parameter will be returned\&. 
.PP
\fBReturns\fP
.RS 4
array|mixed An array of type information if type is not specified, otherwise a specific type\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.2 
.PP
5\&.0 
.RE
.PP

.SS "mb_http_input ( $type = \fC\fBnull\fP\fP)"
Detect HTTP input character encoding \fBstring $type [optional] \fP Input string specifies the input type\&. 'G' for GET, 'P' for POST, 'C' for COOKIE, 'S' for string, 'L' for list, and 'I' for the whole list (will return array)\&. If type is omitted, it returns the last input type processed\&. 
.PP
\fBReturns\fP
.RS 4
false|string The character encoding name, as per the type\&. If mb_http_input does not process specified HTTP input, it returns false\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.6 
.PP
5\&.0 
.RE
.PP

.SS "mb_http_output ( $encoding = \fC\fBnull\fP\fP)"
Set/Get HTTP output character encoding \fBstring $encoding [optional] \fP If encoding is set, mb_http_output sets the HTTP output character encoding to encoding\&. 
.PP
If encoding is omitted, mb_http_output returns the current HTTP output character encoding\&. 
.PP
\fBReturns\fP
.RS 4
bool|string If encoding is omitted, mb_http_output returns the current HTTP output character encoding\&. Otherwise, true on success or false on failure\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.6 
.PP
5\&.0 
.RE
.PP

.SS "mb_internal_encoding ( $encoding = \fC\fBnull\fP\fP)"
Set/Get internal character encoding \fBstring $encoding [optional] \fP encoding is the character encoding name used for the HTTP input character encoding conversion, HTTP output character encoding conversion, and the default character encoding for string functions defined by the mbstring module\&. 
.PP
\fBReturns\fP
.RS 4
bool|string If encoding is set, then true on success or false on failure\&. If encoding is omitted, then the current character encoding name is returned\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.6 
.PP
5\&.0 
.RE
.PP

.SS "mb_language ( $language = \fC\fBnull\fP\fP)"
Set/Get current language \fBstring $language [optional] \fP Used for encoding e-mail messages\&. Valid languages are 'Japanese', 'ja','English','en' and 'uni' (UTF-8)\&. mb_send_mail uses this setting to encode e-mail\&. 
.PP
Language and its setting is ISO-2022-JP/Base64 for Japanese, UTF-8/Base64 for uni, ISO-8859-1/quoted printable for English\&. 
.PP
\fBReturns\fP
.RS 4
bool|string If language is set and language is valid, it returns true\&. Otherwise, it returns false\&. When language is omitted, it returns the language name as a string\&. If no language is set previously, it then returns false\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.6 
.PP
5\&.0 
.RE
.PP

.SS "mb_list_encodings ()"
Returns an array of all supported encodings \fBstring[] a numerically indexed array\&.  5\&.0 \fP
.SS "mb_ord ( $str,  $encoding)"
Get code point of character \fBstring $str  string $encoding  int|false code point of character or FALSE on failure\&.  7\&.2 \fP
.SS "mb_output_handler ( $contents,  $status)"
Callback function converts character encoding in output buffer \fBstring $contents \fP The contents of the output buffer\&. 
.PP
\fBParameters\fP
.RS 4
\fI$status\fP 
.RE
.PP
The status of the output buffer\&. 
.PP
\fBReturns\fP
.RS 4
string The converted string\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.6 
.PP
5\&.0 
.RE
.PP

.SS "mb_parse_str ( $encoded_string, array & $result = \fC\fBnull\fP\fP)"
Parse GET/POST/COOKIE data and set global variable \fBstring $encoded_string \fP The URL encoded data\&. 
.PP
\fBParameters\fP
.RS 4
\fI$result\fP [optional] 
.RE
.PP
An array containing decoded and character encoded converted values\&. 
.PP
\fBReturns\fP
.RS 4
bool true on success or false on failure\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.6 
.PP
5\&.0 
.RE
.PP

.SS "mb_preferred_mime_name ( $encoding)"
Get MIME charset string \fBstring $encoding \fP The encoding being checked\&. 
.PP
\fBReturns\fP
.RS 4
string The MIME charset string for character encoding encoding\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.6 
.PP
5\&.0 
.RE
.PP

.SS "mb_regex_encoding ( $encoding = \fC\fBnull\fP\fP)"
Returns current encoding for multibyte regex as string \fBstring $encoding [optional] &mbstring\&.encoding\&.parameter;  bool|string If encoding is set, then Returns TRUE on success or FALSE on failure\&. In this case, the internal character encoding is NOT changed\&. If encoding is omitted, then the current character encoding name for a multibyte regex is returned\&.  4\&.2  5\&.0 \fP
.SS "mb_regex_set_options ( $options = \fC\fBnull\fP\fP)"
Set/Get the default options for mbregex functions \fBstring $options [optional] \fP The options to set\&. 
.PP
\fBReturns\fP
.RS 4
string The previous options\&. If options is omitted, it returns the string that describes the current options\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.3 
.PP
5\&.0 
.RE
.PP

.SS "mb_scrub ( $str,  $encoding)"
Scrub broken multibyte strings\&. \fBstring $str  string $encoding  string|false  7\&.2 \fP
.SS "mb_send_mail ( $to,  $subject,  $message,  $additional_headers = \fC\fBnull\fP\fP,  $additional_parameter = \fC\fBnull\fP\fP)"
Send encoded mail \fBstring $to \fP The mail addresses being sent to\&. Multiple recipients may be specified by putting a comma between each address in to\&. This parameter is not automatically encoded\&. 
.PP
\fBParameters\fP
.RS 4
\fI$subject\fP 
.RE
.PP
The subject of the mail\&. 
.PP
\fBParameters\fP
.RS 4
\fI$message\fP 
.RE
.PP
The message of the mail\&. 
.PP
\fBParameters\fP
.RS 4
\fI$additional_headers\fP [optional] 
.RE
.PP
String or array to be inserted at the end of the email header\&. 
.br
 Since 7\&.2\&.0 accepts an array\&. Its keys are the header names and its values are the respective header values\&.
.br
 This is typically used to add extra headers\&. Multiple extra headers are separated with a newline ('\\n')\&. 
.PP
\fBParameters\fP
.RS 4
\fI$additional_parameter\fP [optional] 
.RE
.PP
additional_parameter is a MTA command line parameter\&. It is useful when setting the correct Return-Path header when using sendmail\&. 
.PP
\fBReturns\fP
.RS 4
bool true on success or false on failure\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.6 
.PP
5\&.0 
.RE
.PP

.SS "mb_split ( $pattern,  $string,  $limit = \fC\fBnull\fP\fP)"
Split multibyte string using regular expression \fBstring $pattern \fP The regular expression pattern\&. 
.PP
\fBParameters\fP
.RS 4
\fI$string\fP 
.RE
.PP
The string being split\&. 
.PP
\fBParameters\fP
.RS 4
\fI$limit\fP [optional] If optional parameter limit is specified, it will be split in limit elements as maximum\&. 
.RE
.PP
\fBReturns\fP
.RS 4
string[] The result as an array\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.2 
.PP
5\&.0 
.RE
.PP

.SS "mb_str_split ( $str,  $split_length,  $encoding)"
Function performs string splitting to an array of defined size chunks\&. 
.PP
\fBParameters\fP
.RS 4
\fI$str\fP 
.br
\fI$split_length\fP [optional] 
.br
\fI$encoding\fP [optional] 
.RE
.PP
\fBReturns\fP
.RS 4
string[] 
.RE
.PP
\fBSince\fP
.RS 4
7\&.4 
.RE
.PP

.SS "mb_strcut ( $str,  $start,  $length = \fC\fBnull\fP\fP,  $encoding = \fC\fBnull\fP\fP)"
Get part of string \fBstring $str \fP The string being cut\&. 
.PP
\fBParameters\fP
.RS 4
\fI$start\fP 
.RE
.PP
The position that begins the cut\&. 
.PP
\fBParameters\fP
.RS 4
\fI$length\fP [optional] 
.RE
.PP
The string being decoded\&. 
.PP
\fBParameters\fP
.RS 4
\fI$encoding\fP [optional] &mbstring\&.encoding\&.parameter; 
.RE
.PP
\fBReturns\fP
.RS 4
string mb_strcut returns the portion of str specified by the start and length parameters\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.6 
.PP
5\&.0 
.RE
.PP

.SS "mb_strimwidth ( $str,  $start,  $width,  $trimmarker = \fC\fBnull\fP\fP,  $encoding = \fC\fBnull\fP\fP)"
Get truncated string with specified width \fBstring $str \fP The string being decoded\&. 
.PP
\fBParameters\fP
.RS 4
\fI$start\fP 
.RE
.PP
The start position offset\&. Number of characters from the beginning of string\&. (First character is 0) 
.PP
\fBParameters\fP
.RS 4
\fI$width\fP 
.RE
.PP
The width of the desired trim\&. 
.PP
\fBParameters\fP
.RS 4
\fI$trimmarker\fP [optional] 
.RE
.PP
\fBA\fP string that is added to the end of string when string is truncated\&. 
.PP
\fBParameters\fP
.RS 4
\fI$encoding\fP [optional] &mbstring\&.encoding\&.parameter; 
.RE
.PP
\fBReturns\fP
.RS 4
string The truncated string\&. If trimmarker is set, trimmarker is appended to the return value\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.6 
.PP
5\&.0 
.RE
.PP

.SS "mb_stripos ( $haystack,  $needle,  $offset = \fC0\fP,  $encoding = \fC\fBnull\fP\fP)"
Finds position of first occurrence of a string within another, case insensitive \fBstring $haystack \fP The string from which to get the position of the first occurrence of needle 
.PP
\fBParameters\fP
.RS 4
\fI$needle\fP 
.RE
.PP
The string to find in haystack 
.PP
\fBParameters\fP
.RS 4
\fI$offset\fP [optional] 
.RE
.PP
The position in haystack to start searching 
.PP
\fBParameters\fP
.RS 4
\fI$encoding\fP [optional] 
.RE
.PP
Character encoding name to use\&. If it is omitted, internal character encoding is used\&. 
.PP
\fBReturns\fP
.RS 4
int|false Return the numeric position of the first occurrence of needle in the haystack string, or false if needle is not found\&. 
.RE
.PP
\fBSince\fP
.RS 4
5\&.2 
.RE
.PP

.SS "mb_stristr ( $haystack,  $needle,  $before_needle = \fC\fBfalse\fP\fP,  $encoding = \fC\fBnull\fP\fP)"
Finds first occurrence of a string within another, case insensitive \fBstring $haystack \fP The string from which to get the first occurrence of needle 
.PP
\fBParameters\fP
.RS 4
\fI$needle\fP 
.RE
.PP
The string to find in haystack 
.PP
\fBParameters\fP
.RS 4
\fI$before_needle\fP [optional] 
.RE
.PP
Determines which portion of haystack this function returns\&. If set to true, it returns all of haystack from the beginning to the first occurrence of needle\&. If set to false, it returns all of haystack from the first occurrence of needle to the end, 
.PP
\fBParameters\fP
.RS 4
\fI$encoding\fP [optional] 
.RE
.PP
Character encoding name to use\&. If it is omitted, internal character encoding is used\&. 
.PP
\fBReturns\fP
.RS 4
string|false the portion of haystack, or false if needle is not found\&. 
.RE
.PP
\fBSince\fP
.RS 4
5\&.2 
.RE
.PP

.SS "mb_strlen ( $str,  $encoding = \fC\fBnull\fP\fP)"
Get string length \fBstring $str \fP The string being checked for length\&. 
.PP
\fBParameters\fP
.RS 4
\fI$encoding\fP [optional] &mbstring\&.encoding\&.parameter; 
.RE
.PP
\fBReturns\fP
.RS 4
int the number of characters in string str having character encoding encoding\&. \fBA\fP multi-byte character is counted as 1\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.6 
.PP
5\&.0 
.RE
.PP

.SS "mb_strpos ( $haystack,  $needle,  $offset = \fC0\fP,  $encoding = \fC\fBnull\fP\fP)"
Find position of first occurrence of string in a string \fBstring $haystack \fP The string being checked\&. 
.PP
\fBParameters\fP
.RS 4
\fI$needle\fP 
.RE
.PP
The position counted from the beginning of haystack\&. 
.PP
\fBParameters\fP
.RS 4
\fI$offset\fP [optional] 
.RE
.PP
The search offset\&. If it is not specified, 0 is used\&. 
.PP
\fBParameters\fP
.RS 4
\fI$encoding\fP [optional] &mbstring\&.encoding\&.parameter; 
.RE
.PP
\fBReturns\fP
.RS 4
int|false the numeric position of the first occurrence of needle in the haystack string\&. If needle is not found, it returns false\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.6 
.PP
5\&.0 
.RE
.PP

.SS "mb_strrchr ( $haystack,  $needle,  $before_needle = \fC\fBfalse\fP\fP,  $encoding = \fC\fBnull\fP\fP)"
Finds the last occurrence of a character in a string within another \fBstring $haystack \fP The string from which to get the last occurrence of needle 
.PP
\fBParameters\fP
.RS 4
\fI$needle\fP 
.RE
.PP
The string to find in haystack 
.PP
\fBParameters\fP
.RS 4
\fI$before_needle\fP [optional] 
.RE
.PP
Determines which portion of haystack this function returns\&. If set to true, it returns all of haystack from the beginning to the last occurrence of needle\&. If set to false, it returns all of haystack from the last occurrence of needle to the end, 
.PP
\fBParameters\fP
.RS 4
\fI$encoding\fP [optional] 
.RE
.PP
Character encoding name to use\&. If it is omitted, internal character encoding is used\&. 
.PP
\fBReturns\fP
.RS 4
string|false the portion of haystack\&. or false if needle is not found\&. 
.RE
.PP
\fBSince\fP
.RS 4
5\&.2 
.RE
.PP

.SS "mb_strrichr ( $haystack,  $needle,  $before_needle = \fC\fBfalse\fP\fP,  $encoding = \fC\fBnull\fP\fP)"
Finds the last occurrence of a character in a string within another, case insensitive \fBstring $haystack \fP The string from which to get the last occurrence of needle 
.PP
\fBParameters\fP
.RS 4
\fI$needle\fP 
.RE
.PP
The string to find in haystack 
.PP
\fBParameters\fP
.RS 4
\fI$before_needle\fP [optional] 
.RE
.PP
Determines which portion of haystack this function returns\&. If set to true, it returns all of haystack from the beginning to the last occurrence of needle\&. If set to false, it returns all of haystack from the last occurrence of needle to the end, 
.PP
\fBParameters\fP
.RS 4
\fI$encoding\fP [optional] 
.RE
.PP
Character encoding name to use\&. If it is omitted, internal character encoding is used\&. 
.PP
\fBReturns\fP
.RS 4
string|false the portion of haystack\&. or false if needle is not found\&. 
.RE
.PP
\fBSince\fP
.RS 4
5\&.2 
.RE
.PP

.SS "mb_strripos ( $haystack,  $needle,  $offset = \fC0\fP,  $encoding = \fC\fBnull\fP\fP)"
Finds position of last occurrence of a string within another, case insensitive \fBstring $haystack \fP The string from which to get the position of the last occurrence of needle 
.PP
\fBParameters\fP
.RS 4
\fI$needle\fP 
.RE
.PP
The string to find in haystack 
.PP
\fBParameters\fP
.RS 4
\fI$offset\fP [optional] 
.RE
.PP
The position in haystack to start searching 
.PP
\fBParameters\fP
.RS 4
\fI$encoding\fP [optional] 
.RE
.PP
Character encoding name to use\&. If it is omitted, internal character encoding is used\&. 
.PP
\fBReturns\fP
.RS 4
int|false Return the numeric position of the last occurrence of needle in the haystack string, or false if needle is not found\&. 
.RE
.PP
\fBSince\fP
.RS 4
5\&.2 
.RE
.PP

.SS "mb_strrpos ( $haystack,  $needle,  $offset = \fC0\fP,  $encoding = \fC\fBnull\fP\fP)"
Find position of last occurrence of a string in a string \fBstring $haystack \fP The string being checked, for the last occurrence of needle 
.PP
\fBParameters\fP
.RS 4
\fI$needle\fP 
.RE
.PP
The string to find in haystack\&. 
.PP
\fBParameters\fP
.RS 4
\fI$offset\fP [optional] May be specified to begin searching an arbitrary number of characters into the string\&. Negative values will stop searching at an arbitrary point prior to the end of the string\&. 
.br
\fI$encoding\fP [optional] &mbstring\&.encoding\&.parameter; 
.RE
.PP
\fBReturns\fP
.RS 4
int|false the numeric position of the last occurrence of needle in the haystack string\&. If needle is not found, it returns false\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.6 
.PP
5\&.0 
.RE
.PP

.SS "mb_strstr ( $haystack,  $needle,  $before_needle = \fC\fBfalse\fP\fP,  $encoding = \fC\fBnull\fP\fP)"
Finds first occurrence of a string within another \fBstring $haystack \fP The string from which to get the first occurrence of needle 
.PP
\fBParameters\fP
.RS 4
\fI$needle\fP 
.RE
.PP
The string to find in haystack 
.PP
\fBParameters\fP
.RS 4
\fI$before_needle\fP [optional] 
.RE
.PP
Determines which portion of haystack this function returns\&. If set to true, it returns all of haystack from the beginning to the first occurrence of needle\&. If set to false, it returns all of haystack from the first occurrence of needle to the end, 
.PP
\fBParameters\fP
.RS 4
\fI$encoding\fP [optional] 
.RE
.PP
Character encoding name to use\&. If it is omitted, internal character encoding is used\&. 
.PP
\fBReturns\fP
.RS 4
string|false the portion of haystack, or false if needle is not found\&. 
.RE
.PP
\fBSince\fP
.RS 4
5\&.2 
.RE
.PP

.SS "mb_strtolower ( $str,  $encoding = \fC\fBnull\fP\fP)"
Make a string lowercase \fBstring $str \fP The string being lowercased\&. 
.PP
\fBParameters\fP
.RS 4
\fI$encoding\fP [optional] &mbstring\&.encoding\&.parameter; 
.RE
.PP
\fBReturns\fP
.RS 4
string str with all alphabetic characters converted to lowercase\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.3 
.PP
5\&.0 
.RE
.PP

.SS "mb_strtoupper ( $str,  $encoding = \fC\fBnull\fP\fP)"
Make a string uppercase \fBstring $str \fP The string being uppercased\&. 
.PP
\fBParameters\fP
.RS 4
\fI$encoding\fP [optional] &mbstring\&.encoding\&.parameter; 
.RE
.PP
\fBReturns\fP
.RS 4
string str with all alphabetic characters converted to uppercase\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.3 
.PP
5\&.0 
.RE
.PP

.SS "mb_strwidth ( $str,  $encoding = \fC\fBnull\fP\fP)"
Return width of string \fBstring $str \fP The string being decoded\&. 
.PP
\fBParameters\fP
.RS 4
\fI$encoding\fP [optional] &mbstring\&.encoding\&.parameter; 
.RE
.PP
\fBReturns\fP
.RS 4
int The width of string str\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.6 
.PP
5\&.0 
.RE
.PP

.SS "mb_substitute_character ( $substrchar = \fC\fBnull\fP\fP)"
Set/Get substitution character \fBint|string $substrchar [optional] \fP Specify the Unicode value as an integer, or as one of the following strings:
.PD 0

.IP "\(bu" 2
'none' : no output 
.IP "\(bu" 2
'long': Output character code value (\fBExample\fP: U+3000, JIS+7E7E) 
.IP "\(bu" 2
'entity': Output character entity (\fBExample\fP: È€) 
.PP
\fBReturns\fP
.RS 4
bool|int|string If substchar is set, it returns true for success, otherwise returns false\&. If substchar is not set, it returns the Unicode value, or 'none' or 'long'\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.6 
.PP
5\&.0 
.RE
.PP

.PP

.SS "mb_substr ( $str,  $start,  $length = \fC\fBnull\fP\fP,  $encoding = \fC\fBnull\fP\fP)"
Get part of string \fBstring $str \fP The string being checked\&. 
.PP
\fBParameters\fP
.RS 4
\fI$start\fP 
.RE
.PP
The first position used in str\&. 
.PP
\fBParameters\fP
.RS 4
\fI$length\fP [optional] 
.RE
.PP
The maximum length of the returned string\&. 
.PP
\fBParameters\fP
.RS 4
\fI$encoding\fP [optional] &mbstring\&.encoding\&.parameter; 
.RE
.PP
\fBReturns\fP
.RS 4
string mb_substr returns the portion of str specified by the start and length parameters\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.0\&.6 
.PP
5\&.0 
.RE
.PP

.SS "mb_substr_count ( $haystack,  $needle,  $encoding = \fC\fBnull\fP\fP)"
Count the number of substring occurrences \fBstring $haystack \fP The string being checked\&. 
.PP
\fBParameters\fP
.RS 4
\fI$needle\fP 
.RE
.PP
The string being found\&. 
.PP
\fBParameters\fP
.RS 4
\fI$encoding\fP [optional] &mbstring\&.encoding\&.parameter; 
.RE
.PP
\fBReturns\fP
.RS 4
int The number of times the needle substring occurs in the haystack string\&. 
.RE
.PP
\fBSince\fP
.RS 4
4\&.3 
.PP
5\&.0 
.RE
.PP

.SS "mbereg ( $pattern,  $string, & $registers)"

.PP
\fBParameters\fP
.RS 4
\fI$pattern\fP 
.br
\fI$string\fP 
.br
\fI$registers\fP [optional] 
.RE
.PP
\fBDeprecated\fP
.RS 4
7\&.3 use {
.RE
.PP
\fBSee also\fP
.RS 4
\fBmb_ereg\fP} instead 
.RE
.PP

.SS "mbereg_match ( $pattern,  $string,  $option)"

.PP
\fBParameters\fP
.RS 4
\fI$pattern\fP 
.br
\fI$string\fP 
.br
\fI$option\fP [optional] 
.RE
.PP
\fBDeprecated\fP
.RS 4
7\&.3 use {
.RE
.PP
\fBSee also\fP
.RS 4
\fBmb_ereg_match\fP} instead 
.RE
.PP

.SS "mbereg_replace ( $pattern,  $replacement,  $string,  $option)"

.PP
\fBParameters\fP
.RS 4
\fI$pattern\fP 
.br
\fI$replacement\fP 
.br
\fI$string\fP 
.br
\fI$option\fP [optional] 
.RE
.PP
\fBDeprecated\fP
.RS 4
7\&.3 use {
.RE
.PP
\fBSee also\fP
.RS 4
\fBmb_ereg_replace\fP} instead 
.RE
.PP

.SS "mbereg_search ( $pattern,  $option)"

.PP
\fBParameters\fP
.RS 4
\fI$pattern\fP [optional] 
.br
\fI$option\fP [optional] 
.RE
.PP
\fBDeprecated\fP
.RS 4
7\&.3 use {
.RE
.PP
\fBSee also\fP
.RS 4
\fBmb_ereg_search\fP} instead 
.RE
.PP

.SS "mbereg_search_getpos ()"

.PP
\fBDeprecated\fP
.RS 4
7\&.3 use {
.RE
.PP
\fBSee also\fP
.RS 4
\fBmb_ereg_search_getpos\fP} instead 
.RE
.PP

.SS "mbereg_search_getregs ()"

.PP
\fBDeprecated\fP
.RS 4
7\&.3 use {
.RE
.PP
\fBSee also\fP
.RS 4
\fBmb_ereg_search_getregs\fP} instead 
.RE
.PP

.SS "mbereg_search_init ( $string,  $pattern,  $option)"

.PP
\fBParameters\fP
.RS 4
\fI$string\fP 
.br
\fI$pattern\fP [optional] 
.br
\fI$option\fP [optional] 
.RE
.PP
\fBDeprecated\fP
.RS 4
7\&.3 use {
.RE
.PP
\fBSee also\fP
.RS 4
\fBmb_ereg_search_init\fP} instead 
.RE
.PP

.SS "mbereg_search_pos ( $pattern,  $option)"

.PP
\fBParameters\fP
.RS 4
\fI$pattern\fP [optional] 
.br
\fI$option\fP [optional] 
.RE
.PP
\fBDeprecated\fP
.RS 4
7\&.3 use {
.RE
.PP
\fBSee also\fP
.RS 4
\fBmb_ereg_search_pos\fP} instead 
.RE
.PP

.SS "mbereg_search_regs ( $pattern,  $option)"

.PP
\fBParameters\fP
.RS 4
\fI$pattern\fP [optional] 
.br
\fI$option\fP [optional] 
.RE
.PP
\fBDeprecated\fP
.RS 4
7\&.3 use {
.RE
.PP
\fBSee also\fP
.RS 4
\fBmb_ereg_search_regs\fP} instead 
.RE
.PP

.SS "mbereg_search_setpos ( $position)"

.PP
\fBParameters\fP
.RS 4
\fI$position\fP 
.RE
.PP
\fBDeprecated\fP
.RS 4
7\&.3 use {
.RE
.PP
\fBSee also\fP
.RS 4
\fBmb_ereg_search_setpos\fP} instead 
.RE
.PP

.SS "mberegi ( $pattern,  $string, & $registers)"

.PP
\fBParameters\fP
.RS 4
\fI$pattern\fP 
.br
\fI$string\fP 
.br
\fI$registers\fP [optional] 
.RE
.PP
\fBDeprecated\fP
.RS 4
7\&.3 use {
.RE
.PP
\fBSee also\fP
.RS 4
\fBmb_eregi\fP} instead 
.RE
.PP

.SS "mberegi_replace ( $pattern,  $replacement,  $string, string $option = \fC'msri'\fP)"

.PP
\fBParameters\fP
.RS 4
\fI$pattern\fP 
.br
\fI$replacement\fP 
.br
\fI$string\fP 
.br
\fI$option\fP 
.RE
.PP
\fBReturns\fP
.RS 4
string 
.RE
.PP
\fBDeprecated\fP
.RS 4
7\&.3 use {
.RE
.PP
\fBSee also\fP
.RS 4
\fBmb_eregi_replace\fP} instead 
.RE
.PP

.SS "mbregex_encoding ( $encoding)"

.PP
\fBParameters\fP
.RS 4
\fI$encoding\fP [optional] 
.RE
.PP
\fBDeprecated\fP
.RS 4
7\&.3 use {
.RE
.PP
\fBSee also\fP
.RS 4
\fBmb_regex_encoding\fP} instead 
.RE
.PP

.SS "mbsplit ( $pattern,  $string,  $limit)"

.PP
\fBParameters\fP
.RS 4
\fI$pattern\fP 
.br
\fI$string\fP 
.br
\fI$limit\fP [optional] 
.RE
.PP
\fBDeprecated\fP
.RS 4
7\&.3 use {
.RE
.PP
\fBSee also\fP
.RS 4
\fBmb_split\fP} instead 
.RE
.PP

.SH "Variable Documentation"
.PP 
.SS "const MB_CASE_FOLD 3"

.PP
\fBSince\fP
.RS 4
7\&.3 
.RE
.PP

.SS "const MB_CASE_FOLD_SIMPLE 7"

.PP
\fBSince\fP
.RS 4
7\&.3 
.RE
.PP

.SS "const MB_CASE_LOWER 1"

.SS "const MB_CASE_LOWER_SIMPLE 5"

.PP
\fBSince\fP
.RS 4
7\&.3 
.RE
.PP

.SS "const MB_CASE_TITLE 2"

.SS "const MB_CASE_TITLE_SIMPLE 6"

.PP
\fBSince\fP
.RS 4
7\&.3 
.RE
.PP

.SS "const MB_CASE_UPPER 0"

.SS "const MB_CASE_UPPER_SIMPLE 4"

.PP
\fBSince\fP
.RS 4
7\&.3 
.RE
.PP

.SS "const MB_ONIGURUMA_VERSION '6\&.9\&.1'"

.PP
\fBSince\fP
.RS 4
7\&.4 
.RE
.PP

.SS "const MB_OVERLOAD_MAIL 1"

.SS "const MB_OVERLOAD_REGEX 4"

.SS "const MB_OVERLOAD_STRING 2"

.SH "Author"
.PP 
Generated automatically by Doxygen for Safaricom SDP from the source code\&.
